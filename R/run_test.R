#' Run SPC Chart Test with Advanced Highlighting
#'
#' This function produces an SPC chart from the data frame generated by `create_spc_data`, using the styling defined in `make_chart`.
#' It highlights points based on various conditions: `sigma.signal`, `shift` sequences, `fifteen_more` long runs, `trend` stability, and `two_more` patterns.
#'
#' @param data A data frame containing the SPC data including at least the columns 'x' for dates,
#'        'y' for the measurement values, 'cl' for the centerline, 'lcl' for the lower control limit,
#'        'ucl' for the upper control limit, and various signal columns.
#' @param chart_title A character string representing the title of the chart.
#' @param chart_title_size Numeric value defaulted at 14 but can be changed according to need
#' @param caption Character string that can be used to enter source of the data on bottom right
#' @param caption_size Numeric value that is defaulted at 8 but can be used to change size of caption
#' @return A ggplot object representing the SPC chart with customized aesthetics.
#' @export
#' @importFrom ggplot2 ggplot geom_line geom_point aes labs scale_x_discrete theme_minimal theme element_text element_blank scale_fill_manual
#' @importFrom grDevices rgb
#' @examples
#' data <- create_spc_data(your_data_frame, 'date', 'value', 'xbar')
#' run_test(data, "Comprehensive Monthly SPC Chart")
run_test <- function(data, chart_title = "", chart_title_size = 14, caption = "", caption_size = 8) {
  # Ensure 'x' is a Date object
  if (!inherits(data$x, "Date")) {
    data$x <- parse_date_time(data$x, orders = c("ymd_HMS", "ymd_HM", "ymd_H", "ymd",
                                                 "mdy_HMS", "mdy_HM", "mdy_H", "mdy",
                                                 "dmy_HMS", "dmy_HM", "dmy_H", "dmy",
                                                 "ydm_HMS", "ydm_HM", "ydm_H", "ydm",
                                                 "ym"))
    if (!inherits(data$x, "Date")) {
      data$x <- as.Date(data$x)
    }
  }
  data$x <- as.character(data$x)  # Convert dates to character for categorical plotting

  # Define color palette
  colors <- list(
    y = rgb(74, 121, 134, maxColorValue = 255),
    cl = rgb(216, 159, 62, maxColorValue = 255),
    lcl_ucl = rgb(190, 190, 190, maxColorValue = 255),
    title = rgb(27, 87, 104, maxColorValue = 255),
    annotation = rgb(40, 40, 40, maxColorValue = 255),
    special = rgb(157,15,78, maxColorValue = 255),
    shift_pattern = rgb(153,215,216, maxColorValue = 255),
    fifteen_more = rgb(255,225,138, maxColorValue = 255),
    trend_stability = rgb(190,190,190, maxColorValue = 255),
    normal = rgb(255,255,255, maxColorValue = 255),
    two_of_three = rgb(0,0,0,maxColorValue = 255)
  )

  # Assign condition names for the legend and corresponding colors
  fill_conditions <- rep("Normal", nrow(data))  # Default condition name
  fill_colors <- rep(colors$normal, nrow(data))  # Default color

  # Conditionally assign names and colors based on data signals
  fill_conditions[data$sigma.signal] <- "Sigma Signal"
  fill_colors[data$sigma.signal] <- colors$special

  # Function to compute RLE while skipping NAs
  compute_rle_skip_na <- function(shift_data) {
    na_positions <- is.na(shift_data)
    clean_shift_data <- shift_data[!na_positions]  # Remove NAs

    rle_data <- rle(clean_shift_data)  # Compute RLE on cleaned data
    return(list(lengths = rle_data$lengths, values = rle_data$values, na_positions = na_positions))
  }

  # Use this function in your run_test function
  rle_shift <- compute_rle_skip_na(data$shift)

  # Example of processing RLE data, specifically targeting runs of length 8 or more
  long_shift_runs <- which(rle_shift$lengths >= 8)
  for (i in long_shift_runs) {
    indices <- sum(rle_shift$lengths[1:(i-1)]) + 1: rle_shift$lengths[i]

    # Convert indices back to include NAs
    actual_indices <- which(!rle_shift$na_positions)
    real_indices <- actual_indices[indices]

    fill_conditions[real_indices] <- "Shift"
    fill_colors[real_indices] <- colors$shift_pattern


  }

  # Long runs in fifteen_more
  rle_fifteen <- rle(data$fifteen_more)
  long_fifteen_runs <- which(rle_fifteen$values == TRUE & rle_fifteen$lengths >= 15)
  for (i in long_fifteen_runs) {
    indices <- sum(rle_fifteen$lengths[1:(i-1)]) + 1: rle_fifteen$lengths[i]
    fill_conditions[indices] <- "15+"
    fill_conditions[indices] <- colors$fifteen_more
  }

  # Function to compute RLE while skipping NAs
  compute_rle_skip_na_trend <- function(differences) {
    na_positions <- is.na(differences)
    clean_differences <- differences[!na_positions]  # Remove NAs

    trends <- ifelse(clean_differences < 0, TRUE, ifelse(clean_differences > 0, FALSE, NA))
    rle_trends <- rle(trends)  # Compute RLE on cleaned trends data

    return(list(lengths = rle_trends$lengths, values = rle_trends$values, na_positions = na_positions))
  }

  # Compute differences and apply RLE skipping NA for trend analysis
  differences <- c(diff(data$y), NA)  # Calculate differences and append NA for the last value
  rle_trend <- compute_rle_skip_na_trend(differences)

  # Identify long trend runs (example: 6 or more consecutive)
  long_trend_runs <- which(rle_trend$lengths >= 5)
  for (i in long_trend_runs) {
    indices <- sum(rle_trend$lengths[1:(i-1)]) + 1: rle_trend$lengths[i]

    # Extend the trend marking to one additional point if possible
    if (length(differences) >= max(indices) + 1) {
      indices <- c(indices, max(indices) + 1)
    }

    # Convert indices back to include NAs
    actual_indices <- which(!rle_trend$na_positions)
    real_indices <- actual_indices[indices]

    fill_conditions[real_indices] <- "Trend"
    fill_colors[real_indices] <- colors$trend_stability
  }


  # Apply two out of three rule
  # This must consider if other conditions have already colored the point
  for (i in 3:nrow(data)) {
    if (sum(data$two_more[(i-2):i]) >= 2) {
      # Check if other variations haven't been applied
     if (all(fill_conditions[(i-2):i] == "Normal")) {
        fill_conditions[(i-2):i] <- "Two Out of Three"
        fill_colors[(i-2):i] <- colors$two_of_three
      }
   }
  }

  # Create the plot
  p <- ggplot(data, aes(x = x, y = y)) +
    geom_line(aes(y = cl, group = 1), color = colors$cl, size = 1.25) +
    geom_line(aes(y = lcl, group = 1), color = colors$lcl_ucl, size = 1.25, alpha = 0.5) +
    geom_line(aes(y = ucl, group = 1), color = colors$lcl_ucl, size = 1.25, alpha = 0.5) +
    geom_line(color = colors$y, size = 1.25, group = 1) +
    geom_point(aes(fill = fill_conditions), shape = 21, size = 3, color = colors$y) +
    scale_fill_manual(values = c(
      "Normal" = colors$normal,  # explicitly maintain the color mapping
      "Sigma Signal" = colors$special,
      "Shift" = colors$shift_pattern,
      "15+" = colors$fifteen_more,
      "Trend" = colors$trend_stability,
      "Two Out of Three" = colors$two_of_three
    ), name = NULL) +
    #guides(fill = guide_legend(override.aes = list(alpha = c(0, 1, 1, 1, 1)))) +  # Set alpha for "Normal" to 0 to hide it from the legend
    labs(title = chart_title) +
    scale_x_discrete(name = "Date", breaks = unique(data$x), labels = unique(data$x)) +
    theme_minimal(base_family = "sans") +
    theme(
      plot.title = element_text(color = colors$title, size = chart_title_size, hjust = 0.5),
      plot.background = element_blank(),
      panel.grid = element_blank(),
      panel.background = element_blank(),
      legend.position = "bottom",
      axis.title = element_blank(),
      axis.text.x = element_text(angle = 90, vjust = 0.5, color = "darkgray"),
      axis.text.y = element_text(color = "darkgray"),
      axis.ticks = element_line(color = "darkgray"),
      axis.line = element_line(color = "darkgray"),
      plot.caption = element_text(size = caption_size, color = "darkgray", hjust = 1,family = "Arial"),
      plot.caption.position = "plot"
    )
  # Conditionally add chart title if provided
  if (chart_title != "") {
    p <- p + labs(title = chart_title)
  }

  # Conditionally add caption if provided
  if (caption != "") {
    p <- p + labs(caption = caption)
  }
  return(p)
}
